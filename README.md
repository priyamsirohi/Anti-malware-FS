

* INTRODUCTION:

In a stackable file system, each VFS-based object at the stackable file
system (e.g., in Wrapfs) has a link to one other object on the lower file
system (sometimes called the "hidden" object).  We identify this
symbolically as X->X' where "X" is an object at the upper layer, and X' is
an object on the lower layer.  This form of stacking is a single-layer
linear stacking.

* DETAILS:

Write a stackable, anti-malware file system called amfs.  Amfs should detect
and prevent attempts to read or write bad files.  A "bad file" is defined as
one that contains at least one known malware (e.g., virus) pattern.  Amfs
should be based on wrapfs whose source code is in fs/wrapfs.  I *strongly*
advise you NOT to modify wrapfs itself: keep it as a baseline to compare
your code against.  Instead, make a copy of fs/wrapfs as fs/amfs, rename all
files and symbols/functions from "wrapfs" to "amfs", and modify code in
fs/amfs only.

>>PATTERN DATABASE

You should design a simple file containing plain strings, one per line,
delimited by \n.  Each line represents one bad pattern to look for.
Patterns can be as long or as short as you want.  Patterns should be matched
(case sensitive) using strcmp/memcmp like functions, or any str* function
you think is better.  An example pattern file could look like this:

$ cat pattern.db
badtext
hello
Confidential

Amfs should take a mount time argument to pass the name of the pattern file,
for example:

# mount -t amfs -o pattdb=/mypatterns.db /some/lower/path /mnt/amfs

(Note that you may need to first run "insmod ./fs/amfs/amfs.ko" to
insert the new amfs module; of course, you'll need to remove an older one
that's already loaded, if any.)

After that, you should be able to "cd" to /mnt/amfs and issue normal file
system commands.  Those commands will cause the VFS to call methods in amfs.
You can stick printk lines in amfs to see what gets called and when.

Your code should open the pattern DB file, read it, and keep the list of
patterns to match against in a data structure in memory that you can refer
to from anywhere.  I suggest you attach the pattern data structure to the
amfs superblock private "void* pointer.  You'll need to figure out how
mount options are passed to file systems and make the needed changes to
amfs's code.

Clearly, you should check for all possible errors related to the pattern DB
file: permission, existence, size of it, etc.  (After HW1, I expect you to
know and think about everything that could go wrong.)

Next, you need to add support to manage the pattern DB file.  Design an
ioctl(2) interface in amfs, to support the following actions: add pattern,
remove pattern, and list the contents of the pattern DB.  This is useful as
any anti-malware software needs to update its pattern DB periodically.
Study how ioctl's are passed to file systems and modify amfs as needed.
Demonstrate your ioctls using a user-level program you write, called
amfsctl.  For example:

1. To list known patterns
$ ./amfsctl -l /mnt/amfs

2. To add a new pattern
$ ./amfsctl -a "newpatt" /mnt/amfs

3. To remove an old pattern
$ ./amfsctl -r "oldpatt" /mnt/amfs

Of course, check for errors as needed.  Note you'll need to pass the mount
point to amfsctl so that your ioctl message would go to the right file
system (amfs) and not some other f/s.

>>FILE SYSTEM METHODS

Amfs should intercept all read and write file system methods, and check the
buffers users pass against any of the known malware patterns.  If even one
pattern matches, the file is deemed bad.  If the file is deemed bad, don't
return success.  Instead, you should return an error and "quarantine" the
file.  To quarantine the file, you must mark it as "bad": you can do so by
adding an extended attribute (xattar or EA) such that only the kernel can
control this EA (i.e., it can be read but not removed from userland, even by
root).

If a file is marked as bad using the EA, you should not allow the file to be
opened, read, written, or anything that could lead bad data to be used.  There
should be no way for a malicious user to subvert access through the file
system and get access to that file.  In fact, you should also purge all
records of that file from the page cache and dcache, so cached bad data
isn't returned back to user.  Even attempting to lookup a bad file should
return an error (say, ENOENT).  Even better is if listing a directory
(readdir) would hide bad files from the namespace.  You can, however, allow
a bad file to be deleted.



* EXTRA CREDIT (OPTIONAL, MAX 20 pts)

A. [10 pts] protect pattern file

The pattern file ideally should not be modifiable by users (esp. hackers).
So you should encrypt it just as you did in HW1, and store a safe preamble
to verify the decryption key.  When you mount the file system, you have to
give the name of the pattern DB file (see above).  But now, you cannot open
or read/write until a proper key was given to decrypt it.  Add another amfs
ioctl() to pass the key to the kernel; verify the key is correct, and then
open the file.  Note: this means that until the pattern file has been
decrypted, NO other file system methods should be allowed (that is, users
cannot open/read/write files because there's no way to scan the files yet).


